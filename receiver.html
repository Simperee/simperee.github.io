<!DOCTYPE html>
<!--
  Metrolist Cast Receiver
-->
<html>
<head>
  <script src="//www.gstatic.com/cast/sdk/libs/caf_receiver/v3/cast_receiver_framework.js"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=DM+Serif+Display&family=DM+Sans:opsz,wght@9..40,300;9..40,400&display=swap" rel="stylesheet">
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    :root {
      --text-primary: rgba(255,255,255,0.95);
      --text-secondary: rgba(255,255,255,0.45);
    }

    html, body {
      width: 100%; height: 100%;
      overflow: hidden;
      background: #080808;
      font-family: 'DM Sans', sans-serif;
    }

    cast-media-player {
      display: none;
      --playback-logo-image: none;
      --watermark-image: none;
    }

    /* ── Background: two layers for crossfade, NO backdrop-filter ── */
    .bg-layer {
      position: fixed; inset: 0; z-index: 0;
      background-size: cover;
      background-position: center;
      /* Pre-blur via CSS filter on the element itself — GPU composited, much cheaper */
      filter: blur(40px) brightness(0.35) saturate(1.4);
      transform: scale(1.12); /* hide blur edges */
      opacity: 0;
      transition: opacity 1s ease;
      will-change: opacity;
    }
    .bg-layer.visible { opacity: 1; }

    #bg-vignette {
      position: fixed; inset: 0; z-index: 1;
      background:
        radial-gradient(ellipse at center, transparent 10%, rgba(0,0,0,0.55) 100%),
        linear-gradient(to top, rgba(0,0,0,0.8) 0%, transparent 50%);
      pointer-events: none;
    }

    /* ── Screens ── */
    .screen {
      position: fixed; inset: 0; z-index: 10;
      display: flex;
      opacity: 0;
      transition: opacity 0.6s ease;
    }
    .screen.active { opacity: 1; }

    /* ── Loading ── */
    #screen-loading {
      align-items: center;
      justify-content: center;
    }
    .spinner {
      width: 32px; height: 32px;
      border: 1.5px solid rgba(255,255,255,0.1);
      border-top-color: rgba(255,255,255,0.6);
      border-radius: 50%;
      animation: spin 0.9s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* ── Now Playing ── */
    #screen-playing {
      align-items: flex-end;
      padding: 8vh 8vw;
    }

    .playing-layout {
      display: flex;
      align-items: flex-end;
      gap: 4.5vw;
      width: 100%;
    }

    #album-art {
      width: clamp(160px, 20vw, 300px);
      aspect-ratio: 1;
      border-radius: 8px;
      object-fit: cover;
      box-shadow: 0 20px 50px rgba(0,0,0,0.7);
      flex-shrink: 0;
      opacity: 0;
      transform: translateY(8px);
      transition: opacity 0.5s ease, transform 0.5s ease;
      will-change: opacity, transform;
    }
    #album-art.visible { opacity: 1; transform: translateY(0); }

    .track-info { flex: 1; min-width: 0; padding-bottom: 4px; }

    #track-title {
      font-family: 'DM Serif Display', serif;
      font-size: clamp(1.8rem, 3.8vw, 4.5rem);
      color: var(--text-primary);
      line-height: 1.1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      opacity: 0;
      transform: translateX(-12px);
      transition: opacity 0.5s ease 0.07s, transform 0.5s ease 0.07s;
      will-change: opacity, transform;
    }
    #track-title.visible { opacity: 1; transform: translateX(0); }

    #track-artist {
      font-size: clamp(0.7rem, 1.3vw, 1.2rem);
      font-weight: 300;
      color: var(--text-secondary);
      margin-top: 0.5em;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      opacity: 0;
      transform: translateX(-12px);
      transition: opacity 0.5s ease 0.14s, transform 0.5s ease 0.14s;
      will-change: opacity, transform;
    }
    #track-artist.visible { opacity: 1; transform: translateX(0); }

    .progress-wrap {
      margin-top: 2em;
      opacity: 0;
      transition: opacity 0.5s ease 0.21s;
    }
    .progress-wrap.visible { opacity: 1; }

    #progress-track {
      width: 100%; height: 1.5px;
      background: rgba(255,255,255,0.12);
      border-radius: 2px;
      overflow: hidden;
      position: relative;
    }
    #progress-fill {
      position: absolute; left: 0; top: 0; bottom: 0;
      width: 0%;
      background: rgba(255,255,255,0.85);
      border-radius: 2px;
      transition: width 1s linear;
    }

    .time-row {
      display: flex;
      justify-content: space-between;
      margin-top: 0.5em;
      font-size: clamp(0.6rem, 0.85vw, 0.8rem);
      color: var(--text-secondary);
      font-variant-numeric: tabular-nums;
    }

    /* Visualizer — kept simple, low bar count */
    #visualizer {
      display: flex;
      align-items: flex-end;
      gap: 3px;
      height: 24px;
      margin-top: 1.4em;
      opacity: 0;
      transition: opacity 0.5s ease 0.27s;
    }
    #visualizer.visible { opacity: 1; }

    .bar {
      width: 2.5px;
      border-radius: 2px;
      background: rgba(255,255,255,0.38);
      transform-origin: bottom;
      animation: pulse linear infinite alternate;
    }
    .bar.paused { animation-play-state: paused; }

    @keyframes pulse {
      from { transform: scaleY(0.1); }
      to   { transform: scaleY(1); }
    }

    /* ── Idle / Clock ── */
    #screen-idle {
      align-items: center;
      justify-content: center;
      flex-direction: column;
      gap: 0.5rem;
    }

    #idle-clock {
      font-family: 'DM Serif Display', serif;
      font-size: clamp(5rem, 14vw, 13rem);
      color: rgba(255,255,255,0.88);
      letter-spacing: -0.02em;
      line-height: 1;
    }

    #idle-date {
      font-size: clamp(0.8rem, 1.3vw, 1.2rem);
      font-weight: 300;
      color: var(--text-secondary);
      letter-spacing: 0.2em;
      text-transform: uppercase;
    }

    #idle-hint {
      margin-top: 3rem;
      font-size: clamp(0.6rem, 0.8vw, 0.75rem);
      color: rgba(255,255,255,0.15);
      letter-spacing: 0.28em;
      text-transform: uppercase;
    }
  </style>
</head>
<body>

  <cast-media-player></cast-media-player>

  <!-- Two bg layers for crossfade without backdrop-filter -->
  <div class="bg-layer" id="bg-a"></div>
  <div class="bg-layer" id="bg-b"></div>
  <div id="bg-vignette"></div>

  <div class="screen active" id="screen-loading">
    <div class="spinner"></div>
  </div>

  <div class="screen" id="screen-playing">
    <div class="playing-layout">
      <img id="album-art" src="" alt="" />
      <div class="track-info">
        <div id="track-title">—</div>
        <div id="track-artist">—</div>
        <div class="progress-wrap" id="progress-wrap">
          <div id="progress-track"><div id="progress-fill"></div></div>
          <div class="time-row">
            <span id="time-current">0:00</span>
            <span id="time-total">0:00</span>
          </div>
        </div>
        <div id="visualizer"></div>
      </div>
    </div>
  </div>

  <div class="screen" id="screen-idle">
    <div id="idle-clock">00:00</div>
    <div id="idle-date"></div>
    <div id="idle-hint">Metrolist</div>
  </div>

  <script>
  'use strict';

  const context       = cast.framework.CastReceiverContext.getInstance();
  const playerManager = context.getPlayerManager();

  const bgA         = document.getElementById('bg-a');
  const bgB         = document.getElementById('bg-b');
  const albumArt    = document.getElementById('album-art');
  const trackTitle  = document.getElementById('track-title');
  const trackArtist = document.getElementById('track-artist');
  const progFill    = document.getElementById('progress-fill');
  const timeCurrent = document.getElementById('time-current');
  const timeTotal   = document.getElementById('time-total');
  const progWrap    = document.getElementById('progress-wrap');
  const visualizer  = document.getElementById('visualizer');
  const idleClock   = document.getElementById('idle-clock');
  const idleDate    = document.getElementById('idle-date');

  const screens = {
    loading: document.getElementById('screen-loading'),
    playing: document.getElementById('screen-playing'),
    idle:    document.getElementById('screen-idle'),
  };

  // Reduced bar count for performance
  for (let i = 0; i < 16; i++) {
    const bar = document.createElement('div');
    bar.className = 'bar';
    const dur   = (0.4 + Math.random() * 0.6).toFixed(2);
    const delay = -(Math.random() * 0.5).toFixed(2);
    const maxH  = 10 + Math.floor(Math.random() * 14);
    bar.style.cssText = `height:${maxH}px;animation-duration:${dur}s;animation-delay:${delay}s;`;
    visualizer.appendChild(bar);
  }

  function show(name) {
    Object.entries(screens).forEach(([k, el]) =>
      el.classList.toggle('active', k === name)
    );
  }

  function fmt(s) {
    if (!s || isNaN(s) || s < 0) return '0:00';
    return `${Math.floor(s / 60)}:${Math.floor(s % 60).toString().padStart(2, '0')}`;
  }

  const animEls = [albumArt, trackTitle, trackArtist, progWrap, visualizer];
  function animOut(cb) {
    animEls.forEach(el => el.classList.remove('visible'));
    setTimeout(cb, 350);
  }
  function animIn() {
    animEls.forEach(el => el.classList.add('visible'));
  }

  // Two-layer crossfade — no backdrop-filter needed
  let activeBg = 'a';
  let lastBg   = '';
  function setBg(url) {
    if (!url || url === lastBg) return;
    lastBg = url;
    const next = activeBg === 'a' ? bgB : bgA;
    const curr = activeBg === 'a' ? bgA : bgB;
    next.style.backgroundImage = `url('${url}')`;
    next.classList.add('visible');
    // Wait for transition then hide old layer
    setTimeout(() => curr.classList.remove('visible'), 1000);
    activeBg = activeBg === 'a' ? 'b' : 'a';
  }

  let lastTrackId = '';
  function updateTrack(media) {
    if (!media) return;
    const meta    = media.metadata || {};
    const title   = meta.title  || 'Unknown Track';
    const artist  = meta.artist || meta.albumArtist || meta.subtitle || '';
    const imgUrl  = (meta.images || [])[0]?.url || '';
    const trackId = title + artist;

    if (trackId === lastTrackId) return;
    lastTrackId = trackId;

    animOut(() => {
      trackTitle.textContent  = title;
      trackArtist.textContent = artist;
      timeTotal.textContent   = fmt(media.duration);
      if (imgUrl) {
        albumArt.src = imgUrl;
        setBg(imgUrl);
      }
      animIn();
      show('playing');
    });
  }

  let ticker = null;
  function startTicker() {
    if (ticker) return;
    ticker = setInterval(() => {
      const cur = playerManager.getCurrentTimeSec();
      const dur = playerManager.getDurationSec();
      if (dur > 0) {
        progFill.style.width    = ((cur / dur) * 100).toFixed(2) + '%';
        timeCurrent.textContent = fmt(cur);
      }
    }, 1000);
  }
  function stopTicker() { clearInterval(ticker); ticker = null; }

  function tickClock() {
    const now = new Date();
    idleClock.textContent = `${now.getHours().toString().padStart(2,'0')}:${now.getMinutes().toString().padStart(2,'0')}`;
    idleDate.textContent  = now.toLocaleDateString('en-US', { weekday:'long', month:'long', day:'numeric' });
  }
  tickClock();
  setInterval(tickClock, 15000);

  const ET = cast.framework.events.EventType;
  const PS = cast.framework.messages.PlayerState;

  playerManager.addEventListener(ET.MEDIA_STATUS, () => {
    const media = playerManager.getMediaInformation();
    if (media) updateTrack(media);
  });

  playerManager.addEventListener(ET.PLAYER_STATE, (e) => {
    const bars = visualizer.querySelectorAll('.bar');
    if (e.state === PS.PLAYING) {
      bars.forEach(b => b.classList.remove('paused'));
      startTicker();
      show('playing');
    } else if (e.state === PS.PAUSED) {
      bars.forEach(b => b.classList.add('paused'));
      stopTicker();
    } else if (e.state === PS.IDLE) {
      stopTicker();
      lastTrackId = '';
      setTimeout(() => show('idle'), 800);
    } else if (e.state === PS.BUFFERING) {
      show('loading');
    }
  });

  // Show idle as soon as SDK is ready — don't wait for player events
  context.addEventListener(cast.framework.system.EventType.READY, () => {
    show('idle');
  });

  playerManager.setMessageInterceptor(
    cast.framework.messages.MessageType.LOAD, (req) => {
      if (!req || !req.media) {
        const e = new cast.framework.messages.ErrorData(cast.framework.messages.ErrorType.LOAD_FAILED);
        e.reason = cast.framework.messages.ErrorReason.INVALID_REQUEST;
        return e;
      }
      return req;
    }
  );

  const options = new cast.framework.CastReceiverOptions();
  options.supportedCommands =
    cast.framework.messages.Command.ALL_BASIC_MEDIA |
    cast.framework.messages.Command.QUEUE_PREV      |
    cast.framework.messages.Command.QUEUE_NEXT      |
    cast.framework.messages.Command.STREAM_TRANSFER;

  context.start(options);
  </script>
</body>
</html>
